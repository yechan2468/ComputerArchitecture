## 2.1 서론

`명령어 집합`(`instruction set`): 하드웨어가 이해할 수 있는 명령들(어휘)의 집합.

`명령어 집합`의 종류
- `MIPS`
- `ARMv7`: `MIPS`와 유사하다. 도서 집필 기준 세계에서 가장 인기 있는 명령어 집합이다.
- `Intel x86`: PC와 포스트 PC 시대 클라우드 컴퓨터를 견인 중이다.
- `ARMv8`: 32bit `ARMv7`의 주소 크기가 64비트로 확장된 명령어 집합이다.
이 책에서는 `MIPS`를 중심으로 설명한다.


## 2.2 하드웨어 연산

MIPS 산술 명령어는 반드시 한 종류의 연산만 지시하며, 모든 명령어는 항상 피연산자 3개를 갖는다.

> **덧셈의 예시**

```c
// C
a = (b+c) - (d+e);
```

```assembly
# MIPS
add t0, b, c    # t0 is a temporary variable(register)
add t1, d, e    # temporary variable t1 contains d + e
sub a, t0, t1
```


## 2.3 피연산자

#### 레지스터와 워드

high level language 프로그램과는 달리, MIPS 산술 명령어의 피연산자에는 `레지스터`(`register`)만을 사용할 수 있다는 제약이 있다. 
- `레지스터`: 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 메모리이다. MIPS 구조에서 `레지스터`의 크기는 32bit이고, 현대 컴퓨터에는 보통 32개의 `레지스터`가 있다.
- `워드`(`word`): MIPS에서는 32bit가 한 덩어리로 처리되는 일이 매우 빈번한데, 이것을 `워드`라고 부른다.

#### 메모리 피연산자
- `데이터 전송 명령어`(`data transfer instruction`): 메모리와 레지스터 간에 데이터를 주고받는 명령어
- `병렬 제약`(`alignment restriction`): MIPS에서 워드의 시작 주소가 항상 4의 배수여야 한다는 요구사항. 많은 컴퓨터에서 이 방법을 사용한다.
- `big-endian`, `little-endian`: 컴퓨터는 가장 최상위(big end) 바이트 주소를 워드 주소로 사용하는 것과 최하위(little end) 바이트 주소를 워드 주소로 사용하는 것 두 가지로 나뉜다. MIPS는 big-end 주소를 사용하는 `big-endian` 계열에 속한다.

> **메모리 연산의 예시** <br>
> 변수 a가 레지스터 $s2에 할당되어 있으며 배열 arr의 시작 주소는 $s3에 들어있다고 가정하자.

```c
// C
arr[12] = a + arr[8] + 4;
```

```assembly
# MIPS
lw    $t0, 32($s3)    # lw means 'load word'
add    $t0, $s2, $t0
addi    $t0, $s2, 4    # i in 'addi' means 'immediate'. 4 is called 'immediate operand'
# immediate operand is frequently used, and immediate operation don't need to load constant from memory
# so immediate operation makes calculation more faster and energy-efficient
sw    $t0, 48($s3)    # sw means 'store word'
```


## 2.4 부호있는 수와 부호없는 수

- `LSB`(`least significant bit`): 가장 최하위의 비트, (32비트짜리 워드의 경우) 0번째 비트를 나타낸다.
- `MSB`(`most significant bit`): 가장 최상위의 비트, (32비트짜리 워드의 경우) 31번째 비트를 나타낸다. 부호 있는 수를 표현할 때에는 `MSB`를 부호 비트`(`sign bit`)라고 부르기도 한다.

#### 부호 있는 수의 표현법
양수와 음수를 표현하는 가장 쉬운 방법은 비트 하나를 이용해 양수와 음수를 구별하고, 나머지 비트를 숫자의 크기로 할당하는 것이다. (`부호와 크기`(`sign and magnitude`) 표현법)
- 단점 1. 부호를 어디에 붙여야 하는지 명확하지 않다.
- 단점 2. 덧셈을 할 때 부호를 결정하기 위한 한 단계가 더 필요하다.
- 단점 3. 부호 비트가 크기 비트와 따로 붙기 때문에 양의 0과 음의 0을 가짐. 이는 효율적으로 비트를 사용하고 있다고 보기 어려울 뿐더러, 프로그래머의 부주의로 인한 오류를 발생시킬 수도 있다.

위와 같은 단점 때문에, 부호 있는 이진수를 표현하기 위해 `2의 보수` 표현법이 사용되고 있다.
- 0이 앞에 나오면 양수, 1이 앞에 나오면 음수이다.
- 10진수로 변환하려면, `부호 비트`에는 -2^31을 곱하고, 나머지 비트들은 각각의 위치에 해당하는 양의 기수 값(2^n)을 곱해 모두 더한다.
- 10진수로 변환하기 위한 다른 방법은, 모든 0은 1로, 1은 0으로 바꾸고, 거기에 1을 더하는 것이다. 이는 원래 수와 모든 비트를 역전시킨 수의 합이 -1이라는 데에서 기초한다.
- 2의 보수법으로 표현된 양수는 실제로 왼쪽에 끝없이 많은 0을, 음수는 끝없이 많은 1을 가지고 있다. 따라서 수를 나타내는 binary bit 패턴은 하드웨어  폭에 맞추기 위해 왼쪽의 비트들을 숨기고 있다고 볼 수 있다. 즉, 4비트 0001은 8비트 0000 0001과 같고, 4비트 1101은 8비트 1111 1101과 같다. 
- 위를 응용하자면, 16비트 이진수를 32비트 이진수로 변환할 때 16비트 이진수의 `MSB`를 32비트의 왼쪽 부분에 채우고, 원래의 16비트 값은 32비트의 오른쪽 부분에 그대로 복사하면 된다. 이러한 방법을 `부호확장`(`sign extension`)이라고 부른다.

## 2.5 명령어의 컴퓨터 내부 표현

#### MIPS 명령어의 필드

모든 MIPS 명령어의 길이는 32비트이다. 명령어의 각 부분을 `필드`(`field`)라고 부르고, 명령어의 어떤 부분에 무엇이 오게 되는지 정해 둔 규칙을 `명령어 형식`(`instruction format`)이라고 한다. 아래 표의 `명령어 형식`은 R type(R은 register를 뜻함)과 I type(I는 immediate를 뜻함)을 예시로 들었다.

R type instruction format

| **필드** | `op` | `rs` | `rt` | `rd` | `shamt` | `funct` |
|:----:|:----|:----|:----|:----|:----|:----|
| **비트 수** | 6bits | 5bits | 5bits | 5bits | 5bits | 6bits | 

- `op`: 명령어가 실행할 연산의 종류. `연산자`(`opcode`)라고 부른다. 

> e.g. add: 32, sub:34, lw: 35, sw: 43

- `rs`: 첫번째 source 피연산자 레지스터이다.
- `rt`: 두번째 source 피연산자 레지스터이다.
- `rd`: destination 레지스터이다. 연산 결과가 기억된다.
- `shamt`: 자리 이동량(shift amount).
- `funct`: 기능(function). op 필드에서 연산의 종류를 표시하고, 이 필드에서 그중의 한 연산을 구체적으로 지정한다. `기능 코드`(`function code`)라고도 부른다.

I type instruction format

| **필드** | `op` | `rs ` | `rt` | `constant or address` |
|:----:|:----|:----|:----|:----|:----|:----|
| **비트 수** | 6bits | 5bits | 5bits | 16bits |

- `constant or address`: 상수 또는 메모리 주소. R type의 `rd`, `shamt`, `funct` 필드를 합한 것과 동일한 위치와 크기인 16비트를 사용한다.

형식 별로 op 필드가 가질 수 있는 값들이 다르므로, 하드웨어는 첫번째 필드의 op 필드를 보고 명령어를 무슨 형식으로 해석할 것인지 결정한다. 

#### 레지스터 이름을 숫자로 매핑하기

위에서 확인할 수 있듯이, 레지스터가 들어가는 필드는 5비트가 할당되어 있다. MIPS에서는 레지스터의 종류를 32개로 제한해 놓았고, 때문에 레지스터는 5개의 이진수 비트로 표현이 가능하다. 아래 표는 레지스터 중 일부를 나타낸 표이다.

| **레지스터 이름** | **설명** | **십진수** | **이진수** |
|:----:|:----|:----|:----|
| $zero | 상수 0 | 0 | 00000 |
| $t0 ~ $t7 | temporaries | 8 ~ 15 | 01000 ~ 01111 |
| $s0 ~ $s7 | saved temporaries | 16 ~ 23 | 10000 ~ 10111 |

#### MIPS assembly를 기계어로 번역하기

$t1에 배열 arr의 시작 주소가 기억되어 있고 $s2는 변수 a에 대응된다고 할 때,

```c
// C
arr[10] = a + arr[10];
```

위 C 코드를 컴파일하면

```assembly
# MIPS
lw    $t0, 400($t1)
add    $t0, $s2, $t0
sw    $t0, 400($t1)
```

위 어셈블리를 번역한 기계어 명령어를 십진수로 표현하면

| `op` | `rs` | `rt` | `address` |
|:----|:----|:----|:----|
| 35 | 9 | 8 | 400 | 

| `op` | `rs` | `rt` | `rd` | `shamt` | `funct` |
|:----|:----|:----|:----|:----|:----|
| 0 | 18 | 8 | 8 | 0 | 32 | 

| `op` | `rs` | `rt` | `address` |
|:----|:----|:----|:----|
| 43 | 9 | 8 | 400 | 

위를 완전한 기계어로 번역하면

```
100011    01001    01000    0000 0001 1001 0000
000000    10010    01000    01000    00000    100000
101011    01001    01000    0000 0001 1001 0000
```


## 2.6 논리연산 명령어

논리연산 명령어: 일부 비트들을 워드로 묶는(packing) 작업과, 워드를 비트 단위로 나누는(unpacking) 작업을 담당하는 명령어이다.

`shift`(자리이동)
- 워드 내의 모든 비트를 왼쪽 혹은 오른쪽으로 이동시키고, 이동 후 빈 자리는 0으로 채운다.
- MIPS의 `sll`(shift left logical)과 `srl`(shift right logical)이 `shift`연산을 수행하는 명령어이다.
- 이 때, 앞서 살펴보았던 R type 명령어의 `shamt` 필드가 이 명령어에서 사용된다.
- 왼쪽으로 1비트씩 자리이동하는 것은 각 자리수에 2씩 곱해주는 것과 같으므로, 왼쪽으로 n비트씩 자리이동하면 그 수에 2^n을 곱한 것과 같다.

```
0000 0000 0000 0000 0000 0000 0000 1001
# shift left four times
0000 0000 0000 0000 0000 0000 1001 0000
```

`and`
- 비트 대 비트 연산자로서, 두 비트 값이 모두 1일 경우에만 결과가 1이 된다.
- 어떤 비트 패턴에서 0의 위치에 해당하는 비트들을 감추고(강제로 0으로 만들고), 1의 위치에 해당하는 비트들만을 보여주는(조작을 가하지 않는) 역할을 하기 때문에, `and` 논리연산은 `mask`(`마스크`)라고 불리기도 한다.

```
0000 0000 0000 0000 1100 0110 0101 1110
# and
0000 0000 0000 0000 0000 1111 1111 0000    # bit pattern
# equals
0000 0000 0000 0000 0000 0110 0101 0000
````

`or`
- and와 대칭되는 비트 대 비트 연산자로서, 두 비트 값 중 하나만 1이면 결과가 1이 된다.

```
0000 0000 0000 0000 1001 0110 0011 1110
# or
0000 0000 0000 0000 1100 0011 1111 0000
# equals
0000 0000 0000 0000 1101 0111 1111 1110
```

`not`
- 피연산자 하나를 받아서, 피연산자의 비트가 1이면 결과를 0으로, 0이면 결과를 1로 만든다. 즉, 모든 비트를 역전시킨다.
- MIPS 명령어에는 `not`을 포함하는 대신, `not`과 `or`이 합쳐진 의미의 `nor`만을 명령어 set에 포함시켰다. 이는 3개의 피연산자 형식을 유지하기 위해서인데, `not`은 피연산자 하나를 받아 결과 값 하나를 내놓는 반면 `nor`은 두 개의 피연산자를 받아 결과값 하나를 내놓는다.
- `nor 0` = `not (A or 0)` = `not (A)`이므로, MIPS에서 `not` 논리연산을 사용하려면 피연산자와 `$zero`를 `nor` 명령어로 연산하면 된다. 
 
```
# not
0000 0000 0000 0000 1001 0110 0011 1110
#equals
1111 1111 1111 1111 0110 1001 1100 0001
```


## 2.7 판단을 위한 명령어

#### 판단 기능을 표현하는 명령어

MIPS에서는 `beq`와 `bne` 명령어를 사용해 판단 기능을 표현한다.
`beq`는 `branch if equal`을, `bne`는 `branch if not equal`을 의미하는 `조건부 분기`(`conditional branch`) 명령어이다.
위 두 명령어는 high level 프로그래밍 언어의 조건문이나 반복문을 구현하는 데에 사용된다.

`beq`는 register1과 register2의 값이 같으면 세 번째 피연산자의 주소값에 해당하는 문장으로 가도록(점프하도록) 한다.

```assembly
beq    register1, register2, Label
````

`bne`는 register1과 register2의 값이 같지 않으면 세 번째 피연산자의 주소값에 해당하는 문장으로 가도록 한다.

```assembly
bne    register1, register2, Label
```

#### 경계 검사 기능을 표현하는 명령어

MIPS에서는 `slt`(set on less than), `slti`(~ immediate), `sltu`(~ unsigned), `sltiu`(~ immediate unsigned) 명령어를 사용해 경계 검사 기능을 표현한다. 예를 들어, 다음 pseudo-code에서 3<4가 참이므로 $t0의 값은 1이 되고, 10<5가 거짓이므로 $t1의 값이 0이 된다.
 
```assembly
slt    $t0, 3, 4
slt    $t1, 10, 5
```

MIPS 컴파일러는 위 4개 명령어들과 `bne`, `beq`, 그리고 레지스터 `$zero`의 상수 0을 이용해 모든 비교조건을 만들 수 있다. (같다, 다르다, 작다, 작거나 같다, 크다, 크거나 같다)
접미사 `u`가 붙은 명령어는 부호 없는 정수에 사용된다. 이때, MSB가 1인 음수 표현(e.g. 1111 0011)을 부호없는 정수로 보면, MSB가 0인 어떠한 양수 표현(e.g. 0000 1101)보다 항상 크다는 점을 활용하여 다음과 같은 경계 검사도 가능하다.

```assembly
#MIPS
sltu    $t0, $s1, $t2    # if ( ($s1 >= $t2) or ($s1 < 0) ) $t0 = 0;
```


#### if-then-else 번역하기

```c
// C
if (i==j) 
    f=g+h; 
else
    f=g-h;
```

f, g, h, i, j가 각각 레지스터 $s0부터 $s4까지에 해당한다고 할 때, 위 C언어 문장을 컴파일하면

```assembly
# MIPS
bne    $s3, $s4, Else    # beq를 사용하는 것보다, 조건을 반대로 검사해서 then 부분을 건너뛰게 하는 것이 더 효율적이다.
add $s0, $s1, $s2    # i!=j이면 이 명령어를 실행하지 않는다.
j Exit    # Exit 라벨로 jump하라는 명령이다.
Else: sub    $s0, $s1, $s2
Exit
```

#### while loop 번역하기

```c
// C
while(arr[i] == a)
    i++;
```

i와 a가 레지스터 $s3, $s5에 할당되었고 배열 arr의 시작 주소가 $s6에 저장되어 있다고 할 때, 위 C언어 문장을 컴파일하면

```assembly
Loop: sll    $t1, $s3, 2    # $t1 = i * 4
add $t1, $t1, $s6    # $t1 = arr의 주소
lw $t0, 0($t1)    # $t0 = arr[i]
bne $t0, $s5, Exit    # 반복 조건 검사
addi $s3, $s3, 1    # i++
j    Loop
Exit:
```


#### switch-case

switch를 구현하는 가장 간단한 방법은 계속적인 조건 검사를 통해 switch를 if-then-else의 연속으로 바꾸는 것이지만, 여러 코드의 시작 주소를 표로 만들어 조건에 맞는 코드의 주소로 바로 점프하게 하면 더 효율적으로 구현할 수 있다. 
전자의 경우, 조건을 검사할 때마다 판단을 표현하는 명령어인 `bne` 또는 `beq`이 있는 쪽의 라벨에 몇 번씩 jump해야 하는 반면, 후자의 경우에는 한번만 jump하면 된다.
MIPS에서는 이런 상황을 다루기 위해 `jr`(jump register)라는 명령어를 갖고 있는데, 이 명령어는 레지스터에 명시된 주소로 무조건 점프한다.
> `점프 주소 테이블` `=점프 테이블`(`jump address table` `=jump table`): 프로그램 상의 레이블에 해당하는 주소를 저장하고 있는 배열로, 프로그램은 `점프 테이블`의 주소를 레지스터에 load한 후 그 주소를 사용해 jump한다.


## 2.8 하드웨어의 프로시저 지원

#### 프로시저의 실행과 그에 필요한 것들

`프로시저`(`procedure`)나 함수는 이해하기 쉽고 재사용이 가능하도록 프로그램을 구조화하는 방법 중 하나이다.
프로그램이 `프로시저`를 실행할 때는 다음과 같은 6단계를 거친다.

1. 프로시저가 접근할 수 있는 곳에 인수를 넣는다.
2. 프로시저로 제어를 넘긴다. 
3. 프로시저가 필요로 하는 메모리 자원을 획득한다.
4. 필요한 작업을 수행한다.
5. 호출한 프로그램이 접근할 수 있는 장소에 결과 값을 넣는다.
6. 프로시저는 프로그램 내의 여러 곳에서 호출될 수 있으므로, 원래 위치로 제어를 돌려준다.

다음은 MIPS에서 프로시저 호출에 관련되어 할당된 레지스터들이다.

- `$a0` ~ `$a3`: 전달할 인수(argument)를 가지고 있는 인수 레지스터 4개. 십진수 4~7에 대응된다.
- `$v0` ~ `$v1`: 반환되는 값(value)를 갖게 되는 값 레지스터 2개. 십진수 2~3에 대응된다.
- `$ra`: 호출한 곳으로 되돌아가기 위한 복귀 주소(return address)를 가지고 있는 레지스터 1개. 십진수 31에 대응된다.

MIPS 어셈블리 언어는 레지스터를 할당할 뿐 아니라 프로시저를 위한 명령어인 `jal`(jump-and-link instruction)을 제공한다. 이 명령어는 지정된 주소로 점프하면서, 동시에 다음 명령어의 주소를 `$ra` 레지스터에 저장한다. 위 프로시저 실행단계 중 2단계, 6단계가 다음과 같은 MIPS 명령어로 표현될 수 있다.

```assembly
jal    ProcedureAddress
```

```assembly
jr    $ra
```

또한, 현재 수행중인 명령어의 주소를 기억하기 위해 `PC`(`program counter`)라는 이름의 레지스터가 존재한다. 앞서 살펴보았던 `jal` 명령어는 프로시저에서 복귀할 때 다음 명령어부터 실행하도록 `PC`+4를 레지스터 `$ra`에 저장한다.

그런데 컴파일러가 프로시저를 호출했을 때, 인수 레지스터 4개와 결과 값 레지스터 2개만으로는 프로시저를 번역하기에 부족하여, 프로시저가 실행되기 전에 사용하고 있던 레지스터($t0, $s0 등)를 프로시저에서 사용해야만 하는 경우가 있을 수 있다.
프로시저 호출이 다른 프로그램 부분을 실행하는 데에 영향을 미쳐서는 안되므로, 호출 프로그램이 사용하는 모든 레지스터는 복귀하기 전에 프로시저 호출 전의 상태로 돌려놓아야 한다. 이 때 `레지스터 스필링`을 사용하여 현재 레지스터의 상태를 메모리에 저장한다.
> `레지스터 스필링`(`register spilling`): 사용하지 않는(또는 나중에 사용할) 변수를 메모리에 넣는 일을 뜻한다.
`레지스터 스필링`에는 스택 자료구조가 사용되고, 스택에는 최근에 할당된 주소를 가리키는 `스택 포인터`가 필요하다. 
> `스택 포인터`(`stack pointer`, `$sp`): 레지스터 값 하나가 스택에 저장되거나(데이터를 넣거나, push) 스택에서 복구될(데이터를 꺼낼, pop) 때마다 한 워드씩 조정된다. 
> 역사적 선례에 따라 스택은 높은 주소에서 낮은 주소 쪽으로 성장하므로, 스택에 푸시를 할 때는 스택 포인터 값을 감소시켜야 하고, 팝을 할 때는 스택 포인터 값을 증가시켜야 한다.

#### 간단한 프로시저의 번역 (다른 프로시저를 호출하지 않는 말단(leaf) 프로시저)

```c
// C
int leaf(int g, int h, int i) {
    int f;
    f = g + h + i;
    return f;
}
```

인수 g, h, i가 레지스터 $a0, $a1, $a2에, f가 $s0에 해당할 때, 위 C 코드를 컴파일하면

```assembly
# MIPS
# leaf 프로시저의 시작 지점 라벨
leaf:    
# 프로시저가 사용할 레지스터 자리를 만든 후, 값을 저장
addi    $sp, $sp, -8    # 아래에서, 저장해야 할 레지스터는 $s0, t0이므로 두 개의 워드를 저장할 공간을 만든다.
sw    $s0, 4($sp)
sw    $t0, 0($sp)
# 함수의 몸통 부분
add    $t0, $a0, $a1
add    $s0, $t0, $a2
add    $v0, $s0, $zero    # return f. $v0 = $s0 + 0
# 저장해두었던 값을 스택에서 꺼내 레지스터를 복구
lw    $t0, 0($sp)
lw    $s0, 4($sp)
addi    $sp, $sp, 8
# 원래 호출 프로그램으로 복귀
 jr    $ra 
```

위의 프로그램에서 $s0과 $t0을 모두 저장했다가 원상 복구해야 한다고 가정했는데, 사용하지도 않는 레지스터 값을 저장했다가 복구하면, 쓸데없이 레지스터와 메모리 간 적재(load)와 저장(store) 작업을 하게 된다. 이를 예방하기 위해 MIPS는 레지스터 18개를 두 종류로 나눈다.

- $t0 ~ $t9: temporaries. 프로시저 호출 시, 피호출(callee) 프로그램이 값을 보존해주지 않는 임시 레지스터이다.
- $s0 ~ $s7: saved temporaries. 프로시저 호출 전과 후의 값이 같게 유지되어야 하는 변수 레지스터이다. 피호출 프로그램이 이 레지스터를 사용하면 원래 값을 저장했다가 원상 복구한다.

#### 중첩된 프로시저의 컴파일

중첩된 프로시저를 컴파일할 때에는 값이 보존되어야 할 모든 레지스터를 스택에 넣어야 한다. 
호출 프로그램(caller)은 프로시저 호출 후에도 계속 사용해야 하는 인수 레지스터($a0~$a3)와, 임시 레지스터($t0~$t9)를 스택에 넣는다. 피호출 프로그램이 인수 레지스터와 임시 레지스터를 자기 입맛에 맞게 사용하더라도 호출 프로그램에는 영향이 없어야 한다.
피호출 프로그램(callee)은 피호출 프로그램이 사용하는 저장 레지스터($s0~$s7)와, 복귀 주소 레지스터($ra)를 저장한다. 
복귀한 후에는 메모리에서 값을 꺼내 레지스터를 원상복구한다.

```c
// C
int factorial(int n) {
    if (n<1) return 1;
    else return (n * factorial(n-1));
}
```

인수 n이 레지스터 $a0에 해당할 때, 위 C 코드를 컴파일하면

```assembly
#MIPS
factorial:
            # 복귀 주소($ra)와 n($a0)을 스택에 저장
            addi    $sp, $sp, -8
            sw    $ra, 4($sp)
            sw    $a0, 0($sp)
            # if (n<1)
            slti    $t0, $a0, 1
            beq    $t0, $zero, L1
            # return 1
            addi    $v0, $zero, 1
            addi    $sp, $sp, 8
            jr    $ra    # caller에게로 돌아간다.
L1:
            # else
            addi    $a0, $a0, -1    # 인수에 (n-1)을 넣음
            jal    factorial    # factorial(n-1)
            # 스택에서 복귀 주소($ra)와 인수 값($a0)을 복구
            lw    $a0, 0($sp)
            lw    $ra, 4($sp)
            addi    $sp, $sp, 8
            # return n * factorial(n-1)
            mul    $v0, $a0, $v0
            jr    $ra
```

#### 프로시저 호출 전후의 값 보존 관계

