## 2.1 서론

`명령어 집합`(`instruction set`): 하드웨어가 이해할 수 있는 명령들(어휘)의 집합.

`명령어 집합`의 종류
- `MIPS`
- `ARMv7`: `MIPS`와 유사하다. 도서 집필 기준 세계에서 가장 인기 있는 명령어 집합이다.
- `Intel x86`: PC와 포스트 PC 시대 클라우드 컴퓨터를 견인 중이다.
- `ARMv8`: 32bit `ARMv7`의 주소 크기가 64비트로 확장된 명령어 집합이다.
이 책에서는 `MIPS`를 중심으로 설명한다.


## 2.2 하드웨어 연산

MIPS 산술 명령어는 반드시 한 종류의 연산만 지시하며, 모든 명령어는 항상 피연산자 3개를 갖는다.

> **덧셈의 예시**

```c
// C
a = (b+c) - (d+e);
```

```assembly
# MIPS
add t0, b, c    # t0 is a temporary variable(register)
add t1, d, e    # temporary variable t1 contains d + e
sub a, t0, t1
```


## 2.3 피연산자

#### 레지스터와 워드

high level language 프로그램과는 달리, MIPS 산술 명령어의 피연산자에는 `레지스터`(`register`)만을 사용할 수 있다는 제약이 있다. 
- `레지스터`: 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 메모리이다. MIPS 구조에서 `레지스터`의 크기는 32bit이고, 현대 컴퓨터에는 보통 32개의 `레지스터`가 있다.
- `워드`(`word`): MIPS에서는 32bit가 한 덩어리로 처리되는 일이 매우 빈번한데, 이것을 `워드`라고 부른다.

#### 메모리 피연산자
- `데이터 전송 명령어`(`data transfer instruction`): 메모리와 레지스터 간에 데이터를 주고받는 명령어
- `병렬 제약`(`alignment restriction`): MIPS에서 워드의 시작 주소가 항상 4의 배수여야 한다는 요구사항. 많은 컴퓨터에서 이 방법을 사용한다.
- `big-endian`, `little-endian`: 컴퓨터는 가장 최상위(big end) 바이트 주소를 워드 주소로 사용하는 것과 최하위(little end) 바이트 주소를 워드 주소로 사용하는 것 두 가지로 나뉜다. MIPS는 big-end 주소를 사용하는 `big-endian` 계열에 속한다.

> **메모리 연산의 예시** <br>
> 변수 a가 레지스터 $s2에 할당되어 있으며 배열 arr의 시작 주소는 $s3에 들어있다고 가정하자.

```c
// C
arr[12] = a + arr[8] + 4;
```

```assembly
# MIPS
lw    $t0, 32($s3)    # lw means 'load word'
add    $t0, $s2, $t0
addi    $t0, $s2, 4    # i in 'addi' means 'immediate'. 4 is called 'immediate operand'
# immediate operand is frequently used, and immediate operation don't need to load constant from memory
# so immediate operation makes calculation more faster and energy-efficient
sw    $t0, 48($s3)    # sw means 'store word'
```


## 2.4 부호있는 수와 부호없는 수

- `LSB`(`least significant bit`): 가장 최하위의 비트, (32비트짜리 워드의 경우) 0번째 비트를 나타낸다.
- `MSB`(`most significant bit`): 가장 최상위의 비트, (32비트짜리 워드의 경우) 31번째 비트를 나타낸다. 부호 있는 수를 표현할 때에는 `MSB`를 부호 비트`(`sign bit`)라고 부르기도 한다.

#### 부호 있는 수의 표현법
양수와 음수를 표현하는 가장 쉬운 방법은 비트 하나를 이용해 양수와 음수를 구별하고, 나머지 비트를 숫자의 크기로 할당하는 것이다. (`부호와 크기`(`sign and magnitude`) 표현법)
- 단점 1. 부호를 어디에 붙여야 하는지 명확하지 않다.
- 단점 2. 덧셈을 할 때 부호를 결정하기 위한 한 단계가 더 필요하다.
- 단점 3. 부호 비트가 크기 비트와 따로 붙기 때문에 양의 0과 음의 0을 가짐. 이는 효율적으로 비트를 사용하고 있다고 보기 어려울 뿐더러, 프로그래머의 부주의로 인한 오류를 발생시킬 수도 있다.

위와 같은 단점 때문에, 부호 있는 이진수를 표현하기 위해 `2의 보수` 표현법이 사용되고 있다.
- 0이 앞에 나오면 양수, 1이 앞에 나오면 음수이다.
- 10진수로 변환하려면, `부호 비트`에는 -2^31을 곱하고, 나머지 비트들은 각각의 위치에 해당하는 양의 기수 값(2^n)을 곱해 모두 더한다.
- 10진수로 변환하기 위한 다른 방법은, 모든 0은 1로, 1은 0으로 바꾸고, 거기에 1을 더하는 것이다. 이는 원래 수와 모든 비트를 역전시킨 수의 합이 -1이라는 데에서 기초한다.
- 2의 보수법으로 표현된 양수는 실제로 왼쪽에 끝없이 많은 0을, 음수는 끝없이 많은 1을 가지고 있다. 따라서 수를 나타내는 binary bit 패턴은 하드웨어  폭에 맞추기 위해 왼쪽의 비트들을 숨기고 있다고 볼 수 있다. 즉, 4비트 0001은 8비트 0000 0001과 같고, 4비트 1101은 8비트 1111 1101과 같다. 
- 위를 응용하자면, 16비트 이진수를 32비트 이진수로 변환할 때 16비트 이진수의 `MSB`를 32비트의 왼쪽 부분에 채우고, 원래의 16비트 값은 32비트의 오른쪽 부분에 그대로 복사하면 된다. 이러한 방법을 `부호확장`(`sign extension`)이라고 부른다.

## 2.5 명령어의 컴퓨터 내부 표현

#### MIPS 명령어의 필드

모든 MIPS 명령어의 길이는 32비트이다. 명령어의 각 부분을 `필드`(`field`)라고 부르고, 명령어의 어떤 부분에 무엇이 오게 되는지 정해 둔 규칙을 `명령어 형식`(`instruction format`)이라고 한다. 아래 표의 `명령어 형식`은 R type(R은 register를 뜻함)과 I type(I는 immediate를 뜻함)을 예시로 들었다.

R type instruction format

| **필드** | `op` | `rs` | `rt` | `rd` | `shamt` | `funct` |
|:----:|:----|:----|:----|:----|:----|:----|
| **비트 수** | 6bits | 5bits | 5bits | 5bits | 5bits | 6bits | 

- `op`: 명령어가 실행할 연산의 종류. `연산자`(`opcode`)라고 부른다. 

> e.g. add: 32, sub:34, lw: 35, sw: 43

- `rs`: 첫번째 source 피연산자 레지스터이다.
- `rt`: 두번째 source 피연산자 레지스터이다.
- `rd`: destination 레지스터이다. 연산 결과가 기억된다.
- `shamt`: 자리 이동량(shift amount).
- `funct`: 기능(function). op 필드에서 연산의 종류를 표시하고, 이 필드에서 그중의 한 연산을 구체적으로 지정한다. `기능 코드`(`function code`)라고도 부른다.

I type instruction format

| **필드** | `op` | `rs ` | `rt` | `constant or address` |
|:----:|:----|:----|:----|:----|:----|:----|
| **비트 수** | 6bits | 5bits | 5bits | 16bits |

- `constant or address`: 상수 또는 메모리 주소. R type의 `rd`, `shamt`, `funct` 필드를 합한 것과 동일한 위치와 크기인 16비트를 사용한다.

형식 별로 op 필드가 가질 수 있는 값들이 다르므로, 하드웨어는 첫번째 필드의 op 필드를 보고 명령어를 무슨 형식으로 해석할 것인지 결정한다. 

#### 레지스터 이름을 숫자로 매핑하기

위에서 확인할 수 있듯이, 레지스터가 들어가는 필드는 5비트가 할당되어 있다. MIPS에서는 레지스터의 종류를 32개로 제한해 놓았고, 때문에 레지스터는 5개의 이진수 비트로 표현이 가능하다. 아래 표는 레지스터 중 일부를 나타낸 표이다.

| **레지스터 이름** | **설명** | **십진수** | **이진수** |
|:----:|:----|:----|:----|
| $zero | 상수 0 | 0 | 00000 |
| $t0 ~ $t7 | temporaries | 8 ~ 15 | 01000 ~ 01111 |
| $s0 ~ $s7 | saved temporaries | 16 ~ 23 | 10000 ~ 10111 |

#### MIPS assembly를 기계어로 번역하기

$t1에 배열 arr의 시작 주소가 기억되어 있고 $s2는 변수 a에 대응된다고 할 때,

```c
// C
arr[10] = a + arr[10];
```

위 C 코드를 컴파일하면

```assembly
# MIPS
lw    $t0, 400($t1)
add    $t0, $s2, $t0
sw    $t0, 400($t1)
```

위 어셈블리를 번역한 기계어 명령어를 십진수로 표현하면

| `op` | `rs` | `rt` | `address` |
|:----|:----|:----|:----|
| 35 | 9 | 8 | 400 | 

| `op` | `rs` | `rt` | `rd` | `shamt` | `funct` |
|:----|:----|:----|:----|:----|:----|
| 0 | 18 | 8 | 8 | 0 | 32 | 

| `op` | `rs` | `rt` | `address` |
|:----|:----|:----|:----|
| 43 | 9 | 8 | 400 | 

위를 완전한 기계어로 번역하면

```
100011    01001    01000    0000 0001 1001 0000
000000    10010    01000    01000    00000    100000
101011    01001    01000    0000 0001 1001 0000
```


## 2.6 논리연산 명령어

논리연산 명령어: 일부 비트들을 워드로 묶는(packing) 작업과, 워드를 비트 단위로 나누는(unpacking) 작업을 담당하는 명령어이다.

`shift`(자리이동)
- 워드 내의 모든 비트를 왼쪽 혹은 오른쪽으로 이동시키고, 이동 후 빈 자리는 0으로 채운다.
- MIPS의 `sll`(shift left logical)과 `srl`(shift right logical)이 `shift`연산을 수행하는 명령어이다.
- 이 때, 앞서 살펴보았던 R type 명령어의 `shamt` 필드가 이 명령어에서 사용된다.
- 왼쪽으로 1비트씩 자리이동하는 것은 각 자리수에 2씩 곱해주는 것과 같으므로, 왼쪽으로 n비트씩 자리이동하면 그 수에 2^n을 곱한 것과 같다.

```
0000 0000 0000 0000 0000 0000 0000 1001
# shift left four times
0000 0000 0000 0000 0000 0000 1001 0000
```

`and`
- 비트 대 비트 연산자로서, 두 비트 값이 모두 1일 경우에만 결과가 1이 된다.
- 어떤 비트 패턴에서 0의 위치에 해당하는 비트들을 감추고(강제로 0으로 만들고), 1의 위치에 해당하는 비트들만을 보여주는(조작을 가하지 않는) 역할을 하기 때문에, `and` 논리연산은 `mask`(`마스크`)라고 불리기도 한다.

```
0000 0000 0000 0000 1100 0110 0101 1110
# and
0000 0000 0000 0000 0000 1111 1111 0000    # bit pattern
# equals
0000 0000 0000 0000 0000 0110 0101 0000
````

`or`
- and와 대칭되는 비트 대 비트 연산자로서, 두 비트 값 중 하나만 1이면 결과가 1이 된다.

```
0000 0000 0000 0000 1001 0110 0011 1110
# or
0000 0000 0000 0000 1100 0011 1111 0000
# equals
0000 0000 0000 0000 1101 0111 1111 1110
```

`not`
- 피연산자 하나를 받아서, 피연산자의 비트가 1이면 결과를 0으로, 0이면 결과를 1로 만든다. 즉, 모든 비트를 역전시킨다.
- MIPS 명령어에는 `not`을 포함하는 대신, `not`과 `or`이 합쳐진 의미의 `nor`만을 명령어 set에 포함시켰다. 이는 3개의 피연산자 형식을 유지하기 위해서인데, `not`은 피연산자 하나를 받아 결과 값 하나를 내놓는 반면 `nor`은 두 개의 피연산자를 받아 결과값 하나를 내놓는다.
- `nor 0` = `not (A or 0)` = `not (A)`이므로, MIPS에서 `not` 논리연산을 사용하려면 피연산자와 `$zero`를 `nor` 명령어로 연산하면 된다. 
 
```
# not
0000 0000 0000 0000 1001 0110 0011 1110
#equals
1111 1111 1111 1111 0110 1001 1100 0001
```


## 2.7 판단을 위한 명령어

#### 판단 기능을 표현하는 명령어

MIPS에서는 `beq`와 `bne` 명령어를 사용해 판단 기능을 표현한다.
`beq`는 `branch if equal`을, `bne`는 `branch if not equal`을 의미하는 `조건부 분기`(`conditional branch`) 명령어이다.
위 두 명령어는 high level 프로그래밍 언어의 조건문이나 반복문을 구현하는 데에 사용된다.

`beq`는 register1과 register2의 값이 같으면 세 번째 피연산자의 주소값에 해당하는 문장으로 가도록(점프하도록) 한다.

```assembly
beq    register1, register2, Label
````

`bne`는 register1과 register2의 값이 같지 않으면 세 번째 피연산자의 주소값에 해당하는 문장으로 가도록 한다.

```assembly
bne    register1, register2, Label
```

#### 경계 검사 기능을 표현하는 명령어

MIPS에서는 `slt`(set on less than), `slti`(~ immediate), `sltu`(~ unsigned), `sltiu`(~ immediate unsigned) 명령어를 사용해 경계 검사 기능을 표현한다. 예를 들어, 다음 pseudo-code에서 3<4가 참이므로 $t0의 값은 1이 되고, 10<5가 거짓이므로 $t1의 값이 0이 된다.
 
```assembly
slt    $t0, 3, 4
slt    $t1, 10, 5
```

MIPS 컴파일러는 위 4개 명령어들과 `bne`, `beq`, 그리고 레지스터 `$zero`의 상수 0을 이용해 모든 비교조건을 만들 수 있다. (같다, 다르다, 작다, 작거나 같다, 크다, 크거나 같다)
접미사 `u`가 붙은 명령어는 부호 없는 정수에 사용된다. 이때, MSB가 1인 음수 표현(e.g. 1111 0011)을 부호없는 정수로 보면, MSB가 0인 어떠한 양수 표현(e.g. 0000 1101)보다 항상 크다는 점을 활용하여 다음과 같은 경계 검사도 가능하다.

```assembly
#MIPS
sltu    $t0, $s1, $t2    # if ( ($s1 >= $t2) or ($s1 < 0) ) $t0 = 0;
```


#### if-then-else 번역하기

```c
// C
if (i==j) 
    f=g+h; 
else
    f=g-h;
```

f, g, h, i, j가 각각 레지스터 $s0부터 $s4까지에 해당한다고 할 때, 위 C언어 문장을 컴파일하면

```assembly
# MIPS
bne    $s3, $s4, Else    # beq를 사용하는 것보다, 조건을 반대로 검사해서 then 부분을 건너뛰게 하는 것이 더 효율적이다.
add $s0, $s1, $s2    # i!=j이면 이 명령어를 실행하지 않는다.
j Exit    # Exit 라벨로 jump하라는 명령이다.
Else: sub    $s0, $s1, $s2
Exit
```

#### while loop 번역하기

```c
// C
while(arr[i] == a)
    i++;
```

i와 a가 레지스터 $s3, $s5에 할당되었고 배열 arr의 시작 주소가 $s6에 저장되어 있다고 할 때, 위 C언어 문장을 컴파일하면

```assembly
Loop: sll    $t1, $s3, 2    # $t1 = i * 4
add $t1, $t1, $s6    # $t1 = arr의 주소
lw $t0, 0($t1)    # $t0 = arr[i]
bne $t0, $s5, Exit    # 반복 조건 검사
addi $s3, $s3, 1    # i++
j    Loop
Exit:
```


#### switch-case

switch를 구현하는 가장 간단한 방법은 계속적인 조건 검사를 통해 switch를 if-then-else의 연속으로 바꾸는 것이지만, 여러 코드의 시작 주소를 표로 만들어 조건에 맞는 코드의 주소로 바로 점프하게 하면 더 효율적으로 구현할 수 있다. 
전자의 경우, 조건을 검사할 때마다 판단을 표현하는 명령어인 `bne` 또는 `beq`이 있는 쪽의 라벨에 몇 번씩 jump해야 하는 반면, 후자의 경우에는 한번만 jump하면 된다.
MIPS에서는 이런 상황을 다루기 위해 `jr`(jump register)라는 명령어를 갖고 있는데, 이 명령어는 레지스터에 명시된 주소로 무조건 점프한다.
> `점프 주소 테이블` `=점프 테이블`(`jump address table` `=jump table`): 프로그램 상의 레이블에 해당하는 주소를 저장하고 있는 배열로, 프로그램은 `점프 테이블`의 주소를 레지스터에 load한 후 그 주소를 사용해 jump한다.


## 2.8 하드웨어의 프로시저 지원

#### 프로시저의 실행과 그에 필요한 것들

`프로시저`(`procedure`)나 함수는 이해하기 쉽고 재사용이 가능하도록 프로그램을 구조화하는 방법 중 하나이다.
프로그램이 `프로시저`를 실행할 때는 다음과 같은 6단계를 거친다.

1. 프로시저가 접근할 수 있는 곳에 인수를 넣는다.
2. 프로시저로 제어를 넘긴다. 
3. 프로시저가 필요로 하는 메모리 자원을 획득한다.
4. 필요한 작업을 수행한다.
5. 호출한 프로그램이 접근할 수 있는 장소에 결과 값을 넣는다.
6. 프로시저는 프로그램 내의 여러 곳에서 호출될 수 있으므로, 원래 위치로 제어를 돌려준다.

다음은 MIPS에서 프로시저 호출에 관련되어 할당된 레지스터들이다.

- `$a0` ~ `$a3`: 전달할 인수(argument)를 가지고 있는 인수 레지스터 4개. 십진수 4~7에 대응된다.
- `$v0` ~ `$v1`: 반환되는 값(value)를 갖게 되는 값 레지스터 2개. 십진수 2~3에 대응된다.
- `$ra`: 호출한 곳으로 되돌아가기 위한 복귀 주소(return address)를 가지고 있는 레지스터 1개. 십진수 31에 대응된다.

MIPS 어셈블리 언어는 레지스터를 할당할 뿐 아니라 프로시저를 위한 명령어인 `jal`(jump-and-link instruction)을 제공한다. 이 명령어는 지정된 주소로 점프하면서, 동시에 다음 명령어의 주소를 `$ra` 레지스터에 저장한다. 위 프로시저 실행단계 중 2단계, 6단계가 다음과 같은 MIPS 명령어로 표현될 수 있다.

```assembly
jal    ProcedureAddress
```

```assembly
jr    $ra
```

또한, 현재 수행중인 명령어의 주소를 기억하기 위해 `PC`(`program counter`)라는 이름의 레지스터가 존재한다. 앞서 살펴보았던 `jal` 명령어는 프로시저에서 복귀할 때 다음 명령어부터 실행하도록 `PC`+4를 레지스터 `$ra`에 저장한다.

그런데 컴파일러가 프로시저를 호출했을 때, 인수 레지스터 4개와 결과 값 레지스터 2개만으로는 프로시저를 번역하기에 부족하여, 프로시저가 실행되기 전에 사용하고 있던 레지스터($t0, $s0 등)를 프로시저에서 사용해야만 하는 경우가 있을 수 있다.
프로시저 호출이 다른 프로그램 부분을 실행하는 데에 영향을 미쳐서는 안되므로, 호출 프로그램이 사용하는 모든 레지스터는 복귀하기 전에 프로시저 호출 전의 상태로 돌려놓아야 한다. 이 때 `레지스터 스필링`을 사용하여 현재 레지스터의 상태를 메모리에 저장한다.
> `레지스터 스필링`(`register spilling`): 사용하지 않는(또는 나중에 사용할) 변수를 메모리에 넣는 일을 뜻한다.
`레지스터 스필링`에는 스택 자료구조가 사용되고, 스택에는 최근에 할당된 주소를 가리키는 `스택 포인터`가 필요하다. 
> `스택 포인터`(`stack pointer`, `$sp`): 레지스터 값 하나가 스택에 저장되거나(데이터를 넣거나, push) 스택에서 복구될(데이터를 꺼낼, pop) 때마다 한 워드씩 조정된다. 
> 역사적 선례에 따라 스택은 높은 주소에서 낮은 주소 쪽으로 성장하므로, 스택에 푸시를 할 때는 스택 포인터 값을 감소시켜야 하고, 팝을 할 때는 스택 포인터 값을 증가시켜야 한다.

#### 간단한 프로시저의 번역 (다른 프로시저를 호출하지 않는 말단(leaf) 프로시저)

```c
// C
int leaf(int g, int h, int i) {
    int f;
    f = g + h + i;
    return f;
}
```

인수 g, h, i가 레지스터 $a0, $a1, $a2에, f가 $s0에 해당할 때, 위 C 코드를 컴파일하면

```assembly
# MIPS
# leaf 프로시저의 시작 지점 라벨
leaf:    
# 프로시저가 사용할 레지스터 자리를 만든 후, 값을 저장
addi    $sp, $sp, -8    # 아래에서, 저장해야 할 레지스터는 $s0, t0이므로 두 개의 워드를 저장할 공간을 만든다.
sw    $s0, 4($sp)
sw    $t0, 0($sp)
# 함수의 몸통 부분
add    $t0, $a0, $a1
add    $s0, $t0, $a2
add    $v0, $s0, $zero    # return f. $v0 = $s0 + 0
# 저장해두었던 값을 스택에서 꺼내 레지스터를 복구
lw    $t0, 0($sp)
lw    $s0, 4($sp)
addi    $sp, $sp, 8
# 원래 호출 프로그램으로 복귀
 jr    $ra 
```

위의 프로그램에서 $s0과 $t0을 모두 저장했다가 원상 복구해야 한다고 가정했는데, 사용하지도 않는 레지스터 값을 저장했다가 복구하면, 쓸데없이 레지스터와 메모리 간 적재(load)와 저장(store) 작업을 하게 된다. 이를 예방하기 위해 MIPS는 레지스터 18개를 두 종류로 나눈다.

- $t0 ~ $t9: temporaries. 프로시저 호출 시, 피호출(callee) 프로그램이 값을 보존해주지 않는 임시 레지스터이다.
- $s0 ~ $s7: saved temporaries. 프로시저 호출 전과 후의 값이 같게 유지되어야 하는 변수 레지스터이다. 피호출 프로그램이 이 레지스터를 사용하면 원래 값을 저장했다가 원상 복구한다.

#### 중첩된 프로시저의 컴파일

중첩된 프로시저를 컴파일할 때에는 값이 보존되어야 할 모든 레지스터를 스택에 넣어야 한다. 
프로시저 호출 후에도 계속 사용해야 하는 인수 레지스터($a0~$a3), 임시 레지스터($t0~$t9), 피호출 프로그램이 사용하는 저장 레지스터($s0~$s7), 복귀 주소 레지스터($ra)를 스택에 넣어 저장해야 한다. 그렇게 함으로써 피호출 프로그램이 인수 레지스터와 임시 레지스터를 자기 입맛에 맞게 사용하더라도 호출 프로그램에는 영향이 없어야 한다. 프로시저 호출을 마치고 복귀한 후에는 메모리에서 값을 꺼내 레지스터를 원상복구한다.

```c
// C
int factorial(int n) {
    if (n<1) return 1;
    else return (n * factorial(n-1));
}
```

인수 n이 레지스터 $a0에 해당할 때, 위 C 코드를 컴파일하면

```assembly
#MIPS
factorial:
            # 복귀 주소($ra)와 n($a0)을 스택에 저장
            addi    $sp, $sp, -8
            sw    $ra, 4($sp)
            sw    $a0, 0($sp)
            # if (n<1)
            slti    $t0, $a0, 1
            beq    $t0, $zero, L1
            # return 1
            addi    $v0, $zero, 1
            addi    $sp, $sp, 8
            jr    $ra    # caller에게로 돌아간다.
L1:
            # else
            addi    $a0, $a0, -1    # 인수에 (n-1)을 넣음
            jal    factorial    # factorial(n-1)
            # 스택에서 복귀 주소($ra)와 인수 값($a0)을 복구
            lw    $a0, 0($sp)
            lw    $ra, 4($sp)
            addi    $sp, $sp, 8
            # return n * factorial(n-1)
            mul    $v0, $a0, $v0
            jr    $ra
```

#### 프로시저 호출 전후의 값 보존 관계

| **보존됨** | **보존되지 않음** |
|:----|:----|
| 저장 레지스터($s0~$s7) | 임시 레지스터($t0~$t9) |
| 스택 포인터 레지스터($sp) | 인수 레지스터($a0~$a3) |
| 복귀 주소 레지스터($ra) | 반환값 레지스터($v0~$v1) |
| 스택 포인터 위의 스택 | 스택 포인터 밑의 스택 |

#### MIPS의 메모리 할당 (스택, 힙)

| **세그먼트** | **시작 주소(hex)** |
|:----:|:----|
Stack | ~ 7fff fffc
Dynamic data(heap) | 1001 0000 ~
Static data | 1000 0000
Text | 0040 0000
Reserved | 0000 0000

- `텍스트 세그먼트`(`text segment`): MIPS 기계어 코드가 들어가는 부분.
- `정적 데이터 세그먼트`(`static data segment`): 상수 및 기타 정적 변수들, 배열 등이 이곳에 저장된다.
- `동적 데이터 세그먼트`(`dynamic data segment`): `힙`(`heap`)이라고 부른다.  linked list와 같이 동적으로 늘어났다 줄어들었다 하는 자료구조를 위한 공간이다. (C 언어의 경우) `malloc()`과 `free()`가 힙 공간을 할당받거나 반납하는 명령어이다.
- 스택: 프로시저의 저장된 레지스터와 지역 변수 등이 이곳에 저장된다. 이때, 위 세 개의 세그먼트들은 주소값이 작은 부분에서부터 큰 부분으로 자라나지만, 스택은 주소값이 큰 부분에서 작은 부분으로 자라난다. 즉, 스택은 `힙`과 서로 마주보면서 자라도록 메모리를 할당한다.

- `프로시저 프레임`(`procedure frame` =`activation record`): 프로시저의 저장된 레지스터와 지역 변수를 가지고 있는 스택 영역이다. 
- `프레임 포인터`(`frame pointer`, `$sp`): `프로시저 프레임`의  첫번째 워드를 가리키는 주소값. MIPS 소프트웨어에서 사용된다. 스택 포인터(`$sp`) 값은 프로시저 내에서 `lw`, `sw` 등의 명령을 통해 바뀔 수도 있지만, `$fp`는 `프로시저 프레임`의 첫번째 워드(프로시저의 최상위 주소값)를 사용하므로 스택이 아래 방향으로 자라난다고 해도 변하지 않는다(베이스 레지스터의 역할을 할 수 있다). 이와 같은 이유로 `$fp`를 사용하면 메모리 내 지역 변수에 대한 변위를 이용한 지역 변수 참조가 간단해진다.

프로시저 호출 전, 중, 후의 스택 할당
<image>

## 2.9 MIPS의 32비트 수치를 위한 주소지정 및 복잡한 주소지정 방식

32비트 주소를 사용하는 ISA에서 하나의 워드로 표현할 수 있는 가장 큰 수는 2^32이고, 하나의 워드로 표현할 수 있는 최대 메모리 주소값도 2^32이다. 이 절에서는 명령어와 32비트 메모리 값을 함께 활용해 넓은 범위의 주소를 표현하는 주소지정 방식들을 알아본다.

#### 32비트 상수의 로딩

MIPS에서는 16비트가 넘는 큰 상수가 필요한 경우에 레지스터의 상위 16비트에 상수를 넣는 `lui`(load upper immidiate) 명령어를 제공한다.
레지스터 $s0에 다음 32비트 상수를 채우는 MIPS 어셈블리 코드를 작성한다고 하면,

```
0000 0000 0011 1101 0000 1001 0000 0000
```

다음과 같다.

```assembly
# MIPS
# 상위 16비트에 상수를 넣는다
lui    $s0, 61    # 61(십진수) = 0000 0000 0011 1101(이진수)
# 상위 16비트는 그대로 두고 하위 16비트에 상수를 넣는다
ori    $s0, $s0, 2304    # 2304(십진수) = 0000 1001 0000 0000(이진수)
```

#### MIPS의 주소지정 방식들

1. 수치(immediate) 주소지정: 피연산자는 명령어 내에 있는 상수이다.
2. 레지스터 주소지정: 피연산자(rs)는 레지스터이다.
3. 베이스(base) 또는 변위(displacement) 주소지정: 메모리 내용이 피연산자이다. 메모리 주소는 레지스터와 명령어 내의 상수를 더해서 구한다.
4. PC 상대 주소지정: PC 값과 명령어 내 상수의 합을 더해서 주소를 구한다.
5. 의사직접(pseudodirect) 주소지정: 명령어 내의 26비트를 PC의 상위 비트들과 연접하여 점프 주소를 구한다.

> 예시1) 수치 주소지정 방식
>  `j` (jump) 명령어는 J 타입 명령어로, 6비트의 `op` 필드와 나머지 26비트의 `target address` 필드로 이뤄져 있다.
> 명령어 내에 있는 26비트의 상수를 피연산자로 하여 주소지정을 하는 이 방식을 수치(immediate) 주소지정 방식이라고 한다.

```assembly
# 10000번지 주소로 가라는 명령어이다
j    10000
```

> 예시2) PC 상대 주소지정 방식
> `bne` (branch not equal) 명령어는 I 타입 명령어로, 6비트의 `op` 필드, 5비트의 `rs`와 `rt` 필드, 그리고 나머지 16비트의 `address/immediate` 필드로 이뤄져 있다.
> 새로운 분기 주소는, `새로운 분기 주소` = `레지스터` + `address`로 구할 수 있다. 
> 이때 조건부 분기는 주로 순환문이나 if문에서 사용되어 가까이 있는 명령어로 분기하는 경우가 많으므로, 위 식의 `레지스터`는 현재 PC를 선택하는 것이 이상적이다.
> PC와 address(명령어 내 상수)를 더한 값으로 상대적으로 주소를 지정하는 이 방식을 PC 상대 주소지정 방식이라고 한다.

```assembly
# if ($s0 != $s1) goto Exit;
bne    $s0, $s1, Exit
...
...
Exit:
```

## 2.10 병렬성과 명령어: 동기화

- `데이터 경쟁상태`(`race condition`): 이벤트가 일어나는 순서에 따라 프로그램의 결과가 달라질 수 있는 상황으로, 다른 스레드에서 나온 두 메모리 접근이 같은 위치를 향하고, 그중 적어도 하나가 쓰기이며 이들이 잇따라서 일어날 때 발생한다. 데이터 경쟁상태를 막으려면 태스크들을 동기화시켜야 한다.

#### 멀티프로세서에서 동기화를 구현하기 - 원자적 교환

멀티프로세서에서 동기화를 구현하기 위해서는, 메모리에서 읽고 쓰는 중간에 아무 것도 끼어들 수 없어야 한다. 즉, 메모리 주소에서 읽고 수정하는 것을 원자적으로(atomically) 처리할 능력을 가진 하드웨어 프리미티브가 있어야 한다.
동기화 구현을 위한 하드웨어 프리미티브의 예로 `원자적 교환`(`atomic change` =`atomic swap`)이 있다. 이 연산은 레지스터의 값을 메모리 값과 교환하는 것이다. (MIPS의 경우 `SWP` 명령어)
예를 들어, 0(사용 가능)과 1(사용 불가)로 공유 메모리의 사용 여부를 나타낸 lock이 있다고 하자. 프로세서 A는 레지스터의 값 1과 메모리에 있는 lock을 맞바꿈으로써 lock을 1로 만들고 공유 메모리의 접근을 주장하려 한다. 이 때 만약 다른 프로세서 B가 이미 접근을 주장했었다면, 교환 명령어가 레지스터에서 가져온 값은 1일 것이므로 A는 공유 메모리에 접근하지 못한다.
위에서 사용된 교환 연산은 원자적이기(나뉠 수 없는 것이기) 때문에, 두 프로세서가 모두 레지스터에서 1 값을 받아올 수 없고 레지스터와 메모리 값의 동시 교환은 하드웨어에 의해 순서가 결정된다. 

#### 멀티프로세서에서 동기화를 구현하기 - 특수 적재, 저장 명령어

멀티프로세서에서 동기화를 구현하는 또다른 방법은, 명령어가 마치 원자적인 것처럼 실행되었는지 표현하는 한 쌍의 명령어를 이용하는 것이다.
MIPS에는 이러한 명령어 쌍으로 `load linked`라는 특수 적재 명령어와 `store conditional`이라는 특수 저장 명령어가 있다.

```assembly
again:
    addi    $t0, $zero, 1    # $t0 = 1;
    ll    $t1, 0($s1)    # load linked
    sc    $t0, 0($s1)    # store conditional
    beq    $t0, $zero, again    # if ($t0 == 0) goto again;
    add    $s4, $zero, $t1    # $s4 = $t1;
```

`load linked`과 `store conditional` 명령어 쌍은 위와 같이 순차적으로 사용되는데, 만약 $s1에 대한 `ll`이 $s1에 대한 `sc`가 실행되기 전에 바뀐다면 `sc`는 실패하게 되고 $t0의 레지스터 값을 0으로 만든다.
`sc`는 두 쌍의 명령어 사이에서 $s1 값이 바뀌지 않았을 경우에만 1을 반환하므로, 위 코드는 원자적 교환을 할 때까지 코드 시퀀스를 계속 다시 실행시킨다.


## 2.11 프로그램 번역과 실행

#### 프로그램 번역과 실행 과정

고급 언어 프로그램 → `컴파일러` → 어셈블리 언어 프로그램 → `어셈블러` → 오브젝트 파일(들) → `링커` → 기계어 프로그램 → `로더` → 메모리

- 컴파일러: 컴파일러는 고급 언어 프로그램을 어셈블리 언어 프로그램으로 바꾼다. 상위 수준 언어 프로그램은 어셈블리 언어보다 문장 수가 훨씬 적으므로 프로그래머의 생산성을 높인다.
- 어셈블러: 어셈블리 언어 프로그램을 목적 파일(object file)로 바꾼다. 오브젝트 파일에는 기계어 명령어, 데이터, 명령어를 메모리에 적절히 배치하기 위해 필요한 각종 정보들이 혼합되어 있다.

> UNIX 시스템의 목적 파일은 보통 다음과 같은 여섯 부분으로 구성된다.
> - 목적 파일 헤더: 목적 파일을 구성하는 각 부분의 크기와 위치를 서술한다.
> - 텍스트 세그먼트: 기계어 코드가 들어있다.
> - 정적 데이터 세그먼트: 프로그램 수명 동안 할당되는 데이터가 들어있다. UNIX 프로그램 실행이 끝날 때까지 계속 할당되는 정적 데이터와 프로그램의 요구에 따라 커졌다 작아졌다 하는 동적 데이터 두 가지를 프로그램이 사용할 수 있도록 한다.
> - 재배치(relocation) 정보: 프로그램이 메모리에 적재될 때 절대 주소에 의존하는 명령어와 데이터 워드를 표현한다.
> - 심벌 테이블(symbol table): 외부 참조같이 아직 정의되지 않고 남아 있는 레이블들을 저장한다.
> - 디버깅 정보: 각 모듈이 어떻게 번역되었는지에 대한 간단한 설명이 들어있다. 디버거는 이 정보를 이용해서 기계어와 고급 언어 소스 파일을 연관 짓고 자료구조를 판독한다.

- 링커: 따로따로 어셈블된 기계어 프로그램을 하나로 연결하여, 컴퓨터에서 실행할 수 있는 실행 파일(executable file)을 만든다. 만약 기계어 코드를 따로 어셈블하여 연결하는 방식이 아니라 코드 변경 시마다 전체 프로그램을 다시 컴파일하고 어셈블해야 한다면 컴퓨터의 자원이 낭비된다.

> 링커의 동작은 다음 세 단계로 이뤄진다. 더 자세한 것은 다음 절 '목적 파일의 링크'에서 알아본다.
> 1. 코드와 데이터 모듈을 메모리에 심벌 형태로 올려놓는다.
> 2. 데이터와 명령어 레이블의 주소를 결정한다.
> 3. 외부 및 내부 참조를 해결한다.

> cf) 동적 링크 라이브러리(DLL: dynamically linked library)
> 프로그램을 실행하기 전 정적으로 라이브러리를 링크하는 방법은 속도가 빠르지만, 다음의 단점들이 있다.
> - 라이브러리가 실행 코드의 일부가 되어, 라이브러리가 업데이트되어도 옛날 라이브러리를 사용할 수밖에 없다.
> - 실제 실행 시 호출 여부와 상관 없이, 실행 파일에서 호출될 수 있는 모든 라이브러리 루틴들을 전부 적재해야 한다.
> 초기의 DLL에서는 로더가 동적 링커를 실행시키고, 동적 링커가 모든 외부 참조를 갱신하는 방식으로 링크를 했다. 이 방법의 단점은 호출된 가능성이 있는 모든 라이브러리 루틴을 링크시킨다는 점이다.
> 지금의 DLL에서는 지연(lazy) 프로시저 링키지 방식을 사용하여, 실제로 호출된 후에만 루틴을 링크시킨다.

- 로더: 프로그램을 메인 메모리에 적재(load)해서 실행할 수 있게 하는 시스템 프로그램이다.

> 로더의 동작은 다음 순서로 진행된다.
> 1. 실행 파일 헤더를 읽어서 텍스트와 데이터 세그먼트의 크기를 알아낸다.
> 2. 텍스트와 데이터가 들어갈 만한 주소 공간을 확보한다.
> 3. 실행 파일의 명령어와 데이터를 메모리에 복사한다.
> 4. 주 프로그램에 전달해야 할 인수가 있으면 이를 스택에 복사한다.
> 5. 레지스터를 초기화하고 스택 포인터는 사용 가능한 첫 주소를 가리키게 한다.
> 6. 기동 루틴(start-up routine)으로 점프한다. 이 기동 루틴에서는 인수를 레지스터에 넣고 프로그램의 주 루틴을 호출한다. 주 프로그램에서 기동 루틴으로 복귀하면 exit 시스템 콜을 사용하여 프로그램을 종료시킨다.

#### 목적 파일의 링크

두 목적 파일 A, B를 링크시켜 C로 만든다고 하자. 목적 파일 A, B의 형태는 다음과 같다.

A의 오브젝트 파일 헤더
- 이름: 프로시저 A
- 텍스트 크기: 100(hex)
- 데이터 크기: 20(hex)

| segment | address | instruction |
|:----:|:----:|:----|
| text | 0 | lw    $a0, *0*($gp) |
| text | 4 | jal    *0* |
| text | ... | ... |
| data | *0* | *(X)* |
| data | ... | ... |

A의 lw 명령은 데이터 워드 X의 주소를 사용하고, jal 명령은 프로시저 B의 주소를 사용한다.

B의 오브젝트 파일 헤더
- 이름: 프로시저 B
- 텍스트 크기: 200(hex)
- 데이터 크기: 30(hex)

| segment | address | instruction |
|:----:|:----:|:----|
| text | 0 | sw    $a1, *0*($gp) |
| text | 4 | jal    *0* |
| text | ... | ... |
| data | *0* | *(Y)* |
| data | ... | ... |

B의 sw 명령은 데이터 워드 Y의 주소를 사용하고, jal 명령은 프로시저 A의 주소를 사용한다.

위를 링크시킨 실행 파일은 아래와 같다. MIPS 구조에서 text segment는 0040 0000(hex)번지에서, data segment는 1000 0000(hex)번지에서 시작되고, $gp는 1000 8000(hex)로 초기화됨을 주목하며 보자.

실행 파일 헤더
- 텍스트 크기: 300(hex)
- 데이터 크기: 50(hex)

| segment | address | instruction |
|:----:|:----:|:----|
| text | 0040 0000(hex) | lw    $a0, *8000*($gp) |
| text | 0040 0004(hex) | jal    *0040 0100(hex)* |
| text | ... | ... |
| text | 0040 0100(hex) | sw    $a1, *8020*($gp) |
| text | 0040 0104(hex) | jal    *0040 0000(hex)* |
| text | ... | ... |
| data | 1000 0000(hex) | *(X)* |
| data | ... | ... |
| data | 1000 0020(hex) | *(Y)* |
| data | ... | ... |

원래의 목적파일의 text segment는, A가 0(hex)에서 100(hex)의 공간을, B가 0(hex)에서 200(hex)의 공간을 사용했다. 링크된 후에는 0040 0000(hex)에서 0000 0300(hex)의 공간을 사용한다.
원래의 목적파일의 data segment는, A가 0(hex)에서 20(hex)의 공간을, B가 0(hex)에서 50(hex)의 공간을 사용했다. 링크된 후에는 1000 0000(hex)에서 1000 0070(hex)의 공간을 사용한다.
jal 명령의 주소부는 각각 B의 text segment 시작점과 A의 text segment 시작점이 되었다.
lw와 sw 명령은 전역 포인터($gp)를 베이스 레지스터로 사용한다.
X를 가리키는 A의 lw 명령은 링크 후에 0이 아닌 1000 0000(hex)를 가리켜야 하므로, $gp의 초기값 1000 8000(hex)와 X의 주소값 1000 0000(hex)의 변위차 8000(hex)를 lw의 주소부에 넣어야 한다.
Y를 가리키는 B의 sw 명령은 링크 후에 0이 아닌 1000 0020(hex)를 가리켜야 하므로, $gp의 초기값 1000 8000(hex)와 X의 주소값 1000 0020(hex)의 변위차 8020(hex)를 sw의 주소부에 넣어야 한다.


## 2.17 오류와 함정
- 오류: 강력한 명령어를 사용하면 성능이 좋아진다는 것은 착각이다.
강력한 명령어 대신, 표준 명령어만 사용했을 때 더 좋은 성능을 낼 수도 있다.

- 오류: 최고 성능을 얻기 위해 어셈블리 언어로 프로그램을 작성하는 것은 바람직하지 않을 수 있다.
과거에는 컴파일러가 출력하는 코드의 성능이 좋지 않았지만, 컴파일러 기술이 발전하면서 컴파일한 코드와 손으로 작성한 코드 간의 차이가 급격히 줄어들고 있다.
이제 어셈블리 프로그래머가 오늘날의 컴파일러와 경쟁하려면 프로세서 파이프라이닝과 메모리 계층의 개념을 완전히 이해하고 있어야 한다.
또한, 어셈블리 프로그램은 코딩과 디버깅, 유지보수에 많은 시간이 걸리고, 이식성이 없으며, 유지보수가 어렵다는 문제가 있다는 단점도 있다.

- 오류: 상업용 프로그램의 이진 호환성 때문에 대세 명령어 집합이 변하지 않을 것이라고 생각하지 않아야 한다.
후방으로의(backwards) 이진 호환성은 지켜져야 하는 것이 맞지만, 단례로 x86 구조에서는 지난 35년 동안 평균적으로 한 달에 하나 이상의 명령어가 추가되어 왔다.

- 함정: 바이트 주소를 사용하는 컴퓨터에서 인접 워드 간의 주소 차이가 1이 아니라는 사실을 잊지 않아야 한다.
주소를 하나 증가시키면 다음 워드를 찾을 수 있다고 생각한다면 까다로운 오류를 디버깅해야 할 수 있다.

- 함정: 자동 변수가 정의된 프로시저 외부에서 자동 변수에 대한 포인터를 사용하지 않아야 한다.
프로시저의 결과를 전달할 때, 프로시저 내에서 지역 변수로 선언된 배열을 가리키는 포인터를 포함시키면 예기치 못한 일이 발생할 수 있다. 지역 배열이 저장된 메모리 영역은 프로시저가 종료되자마자 다른 용도로 재사용되기 때문이다.


## 2.18 결론

내장 프로그램 컴퓨터의 두 가지 기본 원리는 숫자와 같은 형태의 명령어를 사용한다는 것과, 변경 가능한 메모리에 프로그램을 저장한다는 것으로, 이 두 원리 때문에 컴퓨터 하나를 이용해 다양한 프로그램을 돌릴 수 있다.
명령어 집합의 선택은 명령어 개수, CPI, 클럭 속도 간의 미묘한 균형을 요하는 문제이다. MIPS에서는 아래와 같은 다양한 설계 원칙들과 생각들을 이용해 그 문제를 해결한다.

설계 원칙 세 가지
- 간단하게 하기 위해서는 규칙적인 것이 좋다: MIPS의 모든 명령어의 길이를 똑같게 함, 어떤 명령어 형식이든 레지스터 필드의 위치를 일정하게 함
- 작은 것이 더 빠르다: MIPS의 레지스터 개수를 32개로 제한함
- 좋은 설계에는 적당한 절충이 필요하다: 모든 명령어의 길이는 같으면 좋지만, 동시에 명령어 내의 주소나 상수부는 클수록 좋음. MIPS는 두 요구사항을 적당히 절충함

생각 두 가지
- 자주 생기는 일을 빠르게: 조건부 분기에 PC 상대주소를 사용함, 큰 상수 피연산자를 위해 수치 주소지정 방식을 도입함
- 추상화: 기계어를 어셈블리 언어로 추상화함, 하드웨어에 없는 명령을 추가해 명령어 집합을 확장함, 의사명령어를 사용함
