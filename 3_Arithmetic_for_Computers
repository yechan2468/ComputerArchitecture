## 3.1 서론

이 장에서는 실수의 표현과 연산 알고리즘, 이러한 알고리즘을 수행하는 하드웨어, 그리고 이 모든 것들이 명령어 집합에 미치는 영향 등을 다룬다.


## 3.2 덧셈과 뺄셈

컴퓨터는 사람들이 생각하는 그대로 덧셈을 수행한다. 즉, 초등학교에서 배운 산수와 다를 바가 없다.
다만, 뺄셈은 뺄 값의 부호를 바꾼 뒤 덧셈을 이용한다.

#### 덧셈과 뺄셈 예제

십진수 2와 십진수 10을 이진법으로 덧셈과 뺄셈을 해보자. 하위 몇 비트를 제외한 상위 비트들은 생략한다.

- 덧셈
    0000 0010
 +  0000 1010
 --------
    0000 1100

만약 바로 한 단계 아랫 자리에서 올림수가 발생했다면, 그 올림수와 현재 자리수의 계산 값을 더한다.

- 뺄셈
    0000 0010
 -  0000 1110
 --------------
    0000 1100

뺄셈은 뺄 값의 부호를 바꾼 뒤(0000 1010 -> 1111 0110) 두 수를 더한다.

    0000 0010
 +  1111 0110
 --------------
    1111 1000

2+10=12 (이진수로 0000 1100), 2-10=-8 (이진수로 1111 1000)이므로 결과가 기대한 것과 같다.

#### 오버플로우

부호 있는 덧셈과 뺄셈에서는,
A+B 덧셈에서 오버플로우가 발생하려면, a. A>=0이고 B>=0일 때, 또는 b. A<0이고 B<0일 때 발생한다.
이때, a.의 경우에서 두 양수를 더한 값이 음수가 되거나, b.의 경우에서 두 음수를 더한 값이 양수가 되었을 때 오버플로가 발생했다는 사실을 탐지할 수 있다.
A-B 뺄셈에서 오버플로우가 발생하려면, 1. A>=0이고 B<0일 때, 또는 2. A<0이고 B>=0일 때 발생한다.
이때, a.의 경우에서 양수에서 음수를 뺀 값이 음수가 되거나, b.의 경우에서 음수에서 양수를 뺀 값이 양수가 되었을 때 오버플로가 발생했다는 사실을 탐지할 수 있다.

그렇다면 부호 없는 덧셈과 뺄셈에서는,

## 3.3 곱셈

## 3.4 나눗셈

## 3.5 부동소수점

## 3.6 병렬성과 산술연산: 서브워드 병렬성

## 3.8 더 빠르게: 서브워드 병렬성과 행렬 곱셈

## 3.9 오류와 함정

## 3.10 결론

